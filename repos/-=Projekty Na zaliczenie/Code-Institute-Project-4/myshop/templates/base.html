{% load static %}
{% load socialaccount %}

<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>{% block title %}My Shop{% endblock %}</title>
	<link rel="stylesheet" href="{% static 'css/style.css' %}" />
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css">
	<link rel="icon" href="{% static 'images/favicon.ico' %}" />
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
</head>

<body>
	{% if messages %}
	<div class="messages">
		{% for message in messages %}
		<div class="alert alert-{{ message.tags }}">
			{{ message }}
		</div>
		{% endfor %}
	</div>
	{% endif %}
	<header>
		<!-- Navbar -->
		<nav class="navbar navbar-expand-lg navbar-light bg-light">
			<div class="container">
				<!-- Logo -->
				<a class="navbar-brand" href="{% url 'home' %}">
					<img src="{% static 'images/logo.webp' %}" alt="Logo" width="120">
				</a>

				<!-- Toggle button for mobile view -->
				<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
					aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
					<span class="navbar-toggler-icon"></span>
				</button>

				<!-- Navbar links -->
				<div class="collapse navbar-collapse" id="navbarNav">
					<ul class="navbar-nav ms-auto">
						<li class="nav-item">
							<a class="nav-link" href="{% url 'home' %}">Home</a>
						</li>

						<!-- Dropdown for categories -->
						<li class="nav-item dropdown">
							<a class="nav-link dropdown-toggle" href="#" id="categoriesDropdown" role="button"
								data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
								Categories
							</a>
							<div class="dropdown-menu" aria-labelledby="categoriesDropdown">
								{% for category in categories %}
								<a class="dropdown-item" href="{% url 'products:category_products' category.slug %}">
									{{ category.name }}
								</a>
								{% endfor %}
							</div>
						</li>

						<!-- Static links -->
						<li class="nav-item">
							<a class="nav-link" href="{% url 'about' %}">About Us</a>
						</li>
						<li class="nav-item">
							<a class="nav-link" href="{% url 'contact' %}">Contact</a>
						</li>

						<!-- Login/Register link -->
						{% if not user.is_authenticated %}
						<li class="nav-item">
							<a class="nav-link" href="#" data-bs-toggle="offcanvas" data-bs-target="#offcanvasRight"
								aria-controls="offcanvasRight">Login/Register</a>
						</li>
						{% else %}
						<li class="nav-item">
							<form method="POST" action="{% url 'accounts:logout' %}">
								{% csrf_token %}
								<button type="submit" class="btn btn-link nav-link"
									style="border: none; background: none;">
									Logout
								</button>
							</form>
						</li>
						{% endif %}
						<li>
							<button id="cart-button">
								<i class="fas fa-shopping-cart"></i>
								<span id="cart-total-items">0</span>
							</button>
						</li>
					</ul>
				</div>
			</div>
		</nav>

		<!-- Offcanvas for Login/Register -->
		<div class="offcanvas offcanvas-end" tabindex="-1" id="offcanvasRight" aria-labelledby="offcanvasRightLabel">
			<div class="offcanvas-header">
				<h5 id="offcanvasRightLabel">REGISTER</h5>
				<button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
			</div>
			<div class="offcanvas-body">
				<!-- Registration Form (initially shown) -->
				<div id="register-form">
					<form method="POST" action="{% url 'accounts:register' %}">
						{% csrf_token %}
						<div class="mb-3">
							<label for="username" class="form-label">Username</label>
							<input type="text" class="form-control" id="username" name="username" required>
						</div>
						<div class="mb-3">
							<label for="email" class="form-label">Email</label>
							<input type="email" class="form-control" id="email" name="email" required>
						</div>
						<div class="mb-3">
							<label for="password" class="form-label">Password</label>
							<input type="password" class="form-control" id="password" name="password" required>
						</div>
						<button type="submit" class="btn btn-primary">Register</button>
					</form>
					<div class="mt-3">
						<a href="#" id="show-login">Already have an account? Login here</a>
					</div>
				</div>

				<!-- Login Form (hidden initially) -->
				<div id="login-form" style="display: none;">
					<form method="POST" action="{% url 'accounts:login' %}">
						{% csrf_token %}
						<div class="mb-3">
							<label for="login-email" class="form-label">Email *</label>
							<input type="email" class="form-control" id="login-email" name="email" required>
						</div>
						<div class="mb-3">
							<label for="login-password" class="form-label">Password *</label>
							<input type="password" class="form-control" id="login-password" name="password" required>
						</div>
						<div class="mb-3">
							<a href="{% url 'accounts:password_reset' %}">Forgot your password?</a>
						</div>
						<button type="submit" class="btn btn-primary">Sign In</button>
					</form>
					<div class="mt-3">
						<a href="#" id="show-register">New customer? Create your account</a>
					</div>
				</div>
			</div>
		</div>


		<!-- Off-Canvas Cart Container -->
		<!-- Przycisk otwierający koszyk -->
		<button id="cart-button">
			<i class="fas fa-shopping-cart"></i> Koszyk
		</button>

		<!-- Cart Off-Canvas Container -->
		<div id="cart-off-canvas" class="off-canvas">
			<div class="cart-header">
				<h2>Shopping Cart</h2>
				<button id="close-cart" class="close-btn">&times;</button>
			</div>

			<!-- Kontener na dynamicznie ładowane elementy koszyka -->
			<div id="cart-items-container">
				<!-- Elementy koszyka będą tutaj dodawane przez JavaScript -->
			</div>

			<!-- Wiadomość o pustym koszyku -->
			<p id="empty-cart-message" style="display: none;">Your cart is empty.</p>

			<!-- Stopka koszyka z sumą i przyciskiem checkout -->
			<div class="cart-footer">
				<p id="cart-subtotal">Subtotal: $0</p>
				<button id="checkout-btn" class="btn">Checkout</button>
			</div>
		</div>

		<!-- Overlay, który pojawia się przy otwartym koszyku -->
		<div id="cart-overlay" class="overlay"></div>


		<!-- Toast Container -->
		<div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
			<div id="successToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
				<div class="toast-header">
					<strong class="me-auto">Success</strong>
					<button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
				</div>
				<div class="toast-body">
					Account created successfully!
				</div>
			</div>
		</div>
	</header>

	<main class="container mt-4">
		{% block content %}
		{% endblock %}
	</main>

	<footer class="footer mt-auto py-3 bg-light">
		<div class="container">
			<span class="text-muted">© 2024 My Shop. All rights reserved.</span>
		</div>
	</footer>
	<script src="https://kit.fontawesome.com/ba182bdcb1.js" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js"></script>

	<!-- JavaScript to handle forms -->
	<script>
		document.addEventListener('DOMContentLoaded', function () {
			const showRegisterLink = document.getElementById('show-register');
			const showLoginLink = document.getElementById('show-login');
			const loginForm = document.getElementById('login-form');
			const registerForm = document.getElementById('register-form');
			const offcanvasElement = document.getElementById('offcanvasRight');
			const offcanvas = new bootstrap.Offcanvas(offcanvasElement);



			// Toggle between login and register forms
			showRegisterLink?.addEventListener('click', function (e) {
				e.preventDefault();
				loginForm.style.display = 'none';
				registerForm.style.display = 'block';
			});

			showLoginLink?.addEventListener('click', function (e) {
				e.preventDefault();
				loginForm.style.display = 'block';
				registerForm.style.display = 'none';
			});

			// Function to handle form submissions
			function handleFormSubmit(form, url) {
				if (!form) return;

				form.addEventListener('submit', async function (event) {
					event.preventDefault();
					console.log('Form submitted to URL:', url); // Debug log

					// Clear previous errors
					form.querySelectorAll('.is-invalid').forEach(el => el.classList.remove('is-invalid'));
					form.querySelectorAll('.invalid-feedback').forEach(el => el.remove());
					const alertDiv = form.querySelector('.alert');
					if (alertDiv) alertDiv.remove();

					const submitButton = form.querySelector('button[type="submit"]');
					submitButton.disabled = true;

					try {
						const formData = new FormData(form);
						// Log form data for debugging
						for (let pair of formData.entries()) {
							console.log(pair[0] + ': ' + pair[1]);
						}

						const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
						console.log('CSRF Token present:', !!csrfToken); // Debug log

						if (!csrfToken) {
							throw new Error('CSRF token not found');
						}

						const response = await fetch(url, {
							method: 'POST',
							headers: {
								'X-CSRFToken': csrfToken,
								'X-Requested-With': 'XMLHttpRequest',
							},
							body: formData
						});

						console.log('Response status:', response.status); // Debug log
						// Log raw response for debugging
						const responseText = await response.text();
						console.log('Raw response:', responseText);

						let data;
						try {
							data = JSON.parse(responseText);
						} catch (e) {
							console.error('JSON parse error:', e);
							throw new Error('Invalid JSON response from server');
						}

						if (response.ok && data.success) {
							const successToast = new bootstrap.Toast(document.getElementById('successToast'));
							document.querySelector('#successToast .toast-body').textContent =
								data.message || 'Logged in successfully!';
							successToast.show();

							offcanvas.hide();

							setTimeout(() => {
								window.location.href = data.redirect_url || '/';
							}, 1000);
						} else {
							submitButton.disabled = false;

							if (data.errors) {
								Object.entries(data.errors).forEach(([field, errors]) => {
									const inputElement = form.querySelector(`[name="${field}"]`);
									if (inputElement) {
										inputElement.classList.add('is-invalid');
										const errorElement = document.createElement('div');
										errorElement.className = 'invalid-feedback';
										errorElement.textContent = Array.isArray(errors) ? errors[0] : errors;
										inputElement.parentNode.appendChild(errorElement);
									}
								});
							}

							// Pokaż ogólny komunikat błędu jeśli jest
							if (data.message) {
								const errorDiv = document.createElement('div');
								errorDiv.className = 'alert alert-danger mt-3';
								errorDiv.textContent = data.message;
								form.insertBefore(errorDiv, form.firstChild);
							}
						}
					} catch (error) {
						console.error('Detailed error:', error); // Detailed error logging
						submitButton.disabled = false;

						const errorDiv = document.createElement('div');
						errorDiv.className = 'alert alert-danger mt-3';
						errorDiv.textContent = 'An error occurred: ' + error.message;
						form.insertBefore(errorDiv, form.firstChild);
					}
				});
			}

			// Initialize form handlers
			const loginFormElement = document.querySelector('#login-form form');
			const registerFormElement = document.querySelector('#register-form form');

			if (loginFormElement) {
				console.log('Login form found, action URL:', loginFormElement.action); // Debug log
				handleFormSubmit(loginFormElement, loginFormElement.action);
			}
			if (registerFormElement) {
				console.log('Register form found, action URL:', registerFormElement.action); // Debug log
				handleFormSubmit(registerFormElement, registerFormElement.action);
			}
		});


		// Główne elementy DOM
		const cartButton = document.getElementById('cart-button');
		const cartOffCanvas = document.getElementById('cart-off-canvas');
		const cartOverlay = document.getElementById('cart-overlay');
		const cartItemsContainer = document.getElementById('cart-items-container');
		const emptyCartMessage = document.getElementById('empty-cart-message');
		const cartSubtotal = document.getElementById('cart-subtotal');
		const closeCartBtn = document.getElementById('close-cart');
		const checkoutBtn = document.getElementById('checkout-btn');

		fetchCartDataOnPageLoad();

		// Funkcje pomocnicze
		function formatPrice(price) {
			return `$${parseFloat(price).toFixed(2)}`;
		}

		// Otwieranie i zamykanie koszyka
		function openCart() {
			cartOffCanvas.classList.add('show');
			cartOverlay.style.display = 'block';
			document.body.style.overflow = 'hidden';
			updateCart(); // Dynamicznie aktualizujemy zawartość koszyka
		}

		// Funkcja do zamykania koszyka
		function closeCart() {
			cartOffCanvas.classList.remove('show');
			cartOverlay.style.display = 'none';
			document.body.style.overflow = '';
		}

		function updateCartTotalItems(totalItems) {
			const cartTotalItemsElement = document.getElementById('cart-total-items');
			cartTotalItemsElement.textContent = totalItems;  // Aktualizuje wyświetlaną liczbę produktów
		}

		// Function to fetch cart data when the page loads (added for initial load update)
		async function fetchCartDataOnPageLoad() {
			try {
				const response = await fetch('/cart/get-items/'); // Fetch the current cart items
				const data = await response.json();

				// NEW: Calculate the total number of items in the cart and update the display
				const totalItems = data.items.reduce((total, item) => total + item.quantity, 0);
				updateCartTotalItems(totalItems);  // Update the number of items in the cart button
			} catch (error) {
				console.error('Error fetching cart data:', error);
			}
		}

		// // Funkcja renderująca elementy koszyka
		// function renderCartItems(items) {
		// 	const cartItemsContainer = document.getElementById('cart-items-container');
		// 	cartItemsContainer.innerHTML = '';  // Wyczyść zawartość przed dodaniem nowych elementów

		// 	items.forEach(item => {
		// 		const itemElement = document.createElement('div');
		// 		itemElement.classList.add('cart-item');
		// 		itemElement.innerHTML = `
		//     <div class="cart-item-details">
		//         <h4>${item.name}</h4>
		//         <div class="price-quantity">
		//             <span class="price">$${item.price}</span>
		//             <div class="quantity-controls">
		//                 <input type="number" class="quantity-input" value="${item.quantity}" min="1" data-product-id="${item.product_id}">
		//             </div>
		//         </div>
		//         <span class="subtotal">Subtotal: $${item.total}</span>
		//     </div>
		//     <button class="remove-item" data-product-id="${item.product_id}">&times;</button>
		// `;

		// 		cartItemsContainer.appendChild(itemElement);

		// 		// Dodaj event listener do przycisku usuwania
		// 		itemElement.querySelector('.remove-item').addEventListener('click', () => {
		// 			removeFromCart(item.product_id);
		// 		});

		// 		// Dodaj event listener do zmiany ilości
		// 		itemElement.querySelector('.quantity-input').addEventListener('change', (e) => {
		// 			updateCartQuantity(item.product_id, e.target.value);
		// 		});
		// 	});
		// }

		// Debounce function to prevent rapid firing of updates while the user is typing
		function debounce(func, delay) {
			let timeout;
			return function (...args) {
				clearTimeout(timeout);
				timeout = setTimeout(() => func.apply(this, args), delay);
			};
		}

		// Function to render cart items in the DOM (dynamically)
		function renderCartItems(items) {
			items.forEach(item => {
				const itemElement = document.createElement('div');
				itemElement.classList.add('cart-item');

				itemElement.innerHTML = `
            <div class="cart-item-details">
                <h4>${item.name}</h4>
                <p>$${item.price}</p>
                <input type="number" class="quantity-input" value="${item.quantity}" min="1" data-product-id="${item.product_id}">
                <p class="subtotal">Subtotal: $${(item.price * item.quantity).toFixed(2)}</p>
            </div>
            <button class="remove-item" data-product-id="${item.product_id}">&times;</button>
        `;

				// Append item to the cart container
				cartItemsContainer.appendChild(itemElement);

				// Add event listener for quantity change
				const quantityInput = itemElement.querySelector('.quantity-input');

				// Use debounce to delay the update until the user finishes changing the quantity
				quantityInput.addEventListener('input', debounce((e) => {
					const newQuantity = parseInt(e.target.value, 10);  // Parse the new quantity as an integer

					if (isNaN(newQuantity) || newQuantity <= 0) {
						// If quantity is invalid or zero, remove the item
						removeFromCart(item.product_id);
					} else {
						// Otherwise, update the quantity
						updateCartQuantity(item.product_id, newQuantity);
					}
				}, 500));  // 500ms delay before the change is processed

				// Add event listener for removing the item
				const removeButton = itemElement.querySelector('.remove-item');
				removeButton.addEventListener('click', () => {
					removeFromCart(item.product_id); // Remove the item from cart
				});
			});
		}


		document.querySelectorAll('.quantity-input').forEach(input => {
			input.addEventListener('change', (e) => {
				const newQuantity = parseInt(e.target.value, 10);  // Parse the new quantity as an integer

				// Debugging: Log the quantity input change event
				console.log(`Quantity input change for product ID ${e.target.dataset.productId}: New Quantity: ${newQuantity}`);

				if (isNaN(newQuantity) || newQuantity <= 0) {
					// Invalid quantity, show an error and reset to 1
					e.target.value = 1;
					showToast('Quantity must be at least 1.', 'error');
				} else {
					// Update the quantity for this product in the cart
					updateCartQuantity(e.target.dataset.productId, newQuantity);
				}
			});
		});

		// Function to dynamically update the quantity of an item in the cart
		async function updateCartQuantity(productId, newQuantity) {
			// Ensure newQuantity is valid
			if (newQuantity <= 0 || isNaN(newQuantity)) {
				console.log(`Invalid quantity for product ID ${productId}. Quantity: ${newQuantity}.`);
				showToast('Invalid quantity. Quantity must be at least 1.', 'error');
				return;
			}

			// Debugging: Log the quantity to be sent to the server
			console.log(`Sending request to update quantity of product ID ${productId} to ${newQuantity}.`);

			try {
				const response = await fetch(`/cart/update/${productId}/`, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'X-CSRFToken': getCsrfToken(),  // Include CSRF token
					},
					body: JSON.stringify({ quantity: newQuantity })  // Send the new valid quantity
				});

				const data = await response.json();

				if (response.ok) {
					console.log(`Quantity update successful for product ID ${productId}:`, data);
					showToast('Quantity updated!');
					await updateCart();  // Refresh the cart
				} else {
					console.log('Error response from server:', response);
					showToast('Error updating quantity', 'error');
				}
			} catch (error) {
				console.error('Error updating cart quantity:', error);
				showToast('Error updating quantity', 'error');
			}
		}


		// Funkcja do usuwania produktu z koszyka
		async function removeFromCart(productId) {
			try {
				const response = await fetch(`/cart/remove/${productId}/`, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'X-CSRFToken': getCsrfToken(),  // Include CSRF token for security
					}
				});

				if (response.ok) {
					const data = await response.json();
					showToast('Product removed from cart!');  // Show success toast
					await updateCart(); // Refresh the cart to reflect changes
				} else {
					showToast('Error removing product from cart', 'error');
				}
			} catch (error) {
				console.error('Error removing from cart:', error);
				showToast('Error removing product from cart', 'error');
			}
		}


		// Function to update and re-render the cart (ensure it properly updates the quantity)
		async function updateCart() {
			try {
				const response = await fetch('/cart/get-items/');
				const data = await response.json();

				// Debugging: Log the received cart data from the server
				console.log('Cart data received from server:', data);

				// Clear the current cart items
				cartItemsContainer.innerHTML = '';

				if (data.items.length === 0) {
					emptyCartMessage.style.display = 'block';
					cartSubtotal.textContent = 'Subtotal: $0.00';
				} else {
					emptyCartMessage.style.display = 'none';

					// Re-render each item in the cart
					data.items.forEach(item => {
						const itemElement = document.createElement('div');
						itemElement.classList.add('cart-item');

						itemElement.innerHTML = `
                    <div class="cart-item-details">
                        <h4>${item.name}</h4>
                        <p>$${item.price}</p>
                        <input type="number" class="quantity-input" value="${item.quantity}" min="1" data-product-id="${item.product_id}">
                        <p class="subtotal">Subtotal: $${(item.price * item.quantity).toFixed(2)}</p>
                    </div>
                    <button class="remove-item" data-product-id="${item.product_id}">&times;</button>
                `;

						// Append item to the cart container
						cartItemsContainer.appendChild(itemElement);

						// Add event listeners for quantity change
						const quantityInput = itemElement.querySelector('.quantity-input');
						quantityInput.addEventListener('change', (e) => {
							const newQuantity = parseInt(e.target.value, 10);
							if (isNaN(newQuantity) || newQuantity <= 0) {
								e.target.value = 1;
								showToast('Quantity must be at least 1.', 'error');
							} else {
								updateCartQuantity(item.product_id, newQuantity);
							}
						});

						// Add event listeners for removing an item
						const removeButton = itemElement.querySelector('.remove-item');
						removeButton.addEventListener('click', () => {
							removeFromCart(item.product_id);
						});
					});

					// Update the subtotal with the new total from the server response
					cartSubtotal.textContent = `Subtotal: $${data.total}`;
				}
			} catch (error) {
				console.error('Error updating cart:', error);
				showToast('Error updating cart', 'error');
			}
		}




		function getCsrfToken() {
			return document.querySelector('[name=csrfmiddlewaretoken]').value;
		}


		// Dodawanie produktu do koszyka
		async function addToCart(productId, quantity = 1, stock = 0) {
			if (quantity > stock) {
				showToast(`Only ${stock} items available in stock`, 'error');
				return;
			}

			try {
				const response = await fetch(`/cart/add/${productId}/`, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'X-CSRFToken': getCsrfToken(),
					},
					body: JSON.stringify({ quantity: quantity })
				});

				if (response.ok) {
					const data = await response.json();
					showToast('Product added to cart successfully!');
					await updateCart();
					openCart(); // Otwórz koszyk po dodaniu produktu
				} else {
					const errorData = await response.json();
					showToast(errorData.message, 'error');
				}
			} catch (error) {
				console.error('Error adding to cart:', error);
				showToast('Error adding product to cart', 'error');
			}
		}

		// Dodanie obsługi walidacji dla przycisku "Add to Cart"
		document.querySelectorAll('.add-to-cart').forEach(button => {
			button.addEventListener('click', (e) => {
				const productId = e.target.dataset.productId;
				const stock = e.target.dataset.stock; // Zdobądź ilość dostępnego stocku
				const quantity = 1; // Przykład, możesz dynamicznie ustawić ilość z pola
				addToCart(productId, quantity, stock);
			});
		});


		// Funkcja do wyświetlania toastów
		function showToast(message, type = 'success') {
			const toast = new bootstrap.Toast(document.getElementById('successToast'));
			const toastBody = document.querySelector('.toast-body');
			toastBody.textContent = message;
			toast.show();
		}

		// Event Listeners
		cartButton.addEventListener('click', openCart);
		closeCartBtn.addEventListener('click', closeCart);
		cartOverlay.addEventListener('click', closeCart);

		// Inicjalizacja
		document.addEventListener('DOMContentLoaded', () => {
			// Dodaj obsługę kliknięcia dla wszystkich przycisków "Add to Cart"
			document.querySelectorAll('.add-to-cart').forEach(button => {
				button.addEventListener('click', (e) => {
					const productId = e.target.dataset.productId;
					addToCart(productId);
				});
			});
		});

		async function logCartState() {
			try {
				const response = await fetch('/cart/get-items/');
				const data = await response.json();

				console.log("=== Aktualny stan koszyka ===");
				console.log(`Liczba przedmiotów: ${data.items.length}`);
				console.log(`Łączna wartość: ${data.total}`);

				// Szczegóły każdego produktu
				data.items.forEach((item, index) => {
					console.log(`Produkt #${index + 1}:`);
					console.log(`  Nazwa: ${item.name}`);
					console.log(`  Ilość: ${item.quantity}`);
					console.log(`  Cena: ${item.price}`);
					console.log(`  Wartość całkowita: ${item.total}`);
				});

			} catch (error) {
				console.error('Błąd podczas pobierania stanu koszyka:', error);
			}
		}


	</script>

</body>

</html>